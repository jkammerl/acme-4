/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "ACME4Editor.h"


//==============================================================================
ACME4PluginAudioProcessor::ACME4PluginAudioProcessor()
{
    // Set up some default values..
    lastUIWidth = 400;
    lastUIHeight = 200;

    lastPosInfo.resetToDefault();

}

ACME4PluginAudioProcessor::~ACME4PluginAudioProcessor()
{
}

//==============================================================================
int ACME4PluginAudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float ACME4PluginAudioProcessor::getParameter (int index)
{
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way!
    switch (index)
    {
        default:            return 0.0f;
    }
}

void ACME4PluginAudioProcessor::setParameter (int index, float newValue)
{
    // This method will be called by the host, probably on the audio thread, so
    // it's absolutely time-critical. Don't use critical sections or anything
    // UI-related, or anything at all that may block in any way!
    switch (index)
    {
        default:            break;
    }
}

const String ACME4PluginAudioProcessor::getParameterName (int index)
{
    switch (index)
    {
        default:            break;
    }

    return String::empty;
}

const String ACME4PluginAudioProcessor::getParameterText (int index)
{
    return String (getParameter (index), 2);
}

//==============================================================================
void ACME4PluginAudioProcessor::prepareToPlay (double sampleRate, int /*samplesPerBlock*/)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..

}

void ACME4PluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    keyboardState.reset();
}

void ACME4PluginAudioProcessor::reset()
{
    // Use this method as the place to clear any delay lines, buffers, etc, as it
    // means there's been a break in the audio's continuity.

}

void ACME4PluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    int channel;
	
	// ask the host for the current time so we can display it...
    AudioPlayHead::CurrentPositionInfo newTime;
	
	if (getPlayHead() != 0 && getPlayHead()->getCurrentPosition (newTime))
    {
        // Successfully got the current time from the host..
        lastPosInfo = newTime;
    }
    else
    {
        // If the host fails to fill-in the current time, we'll just clear it to a default..
        lastPosInfo.resetToDefault();
    }
	
	if (newTime.isPlaying || newTime.isRecording) {
		
		const double beats16th  = fmod (newTime.ppqPosition, 1.0/(TICKSPEED/4.0)) / (1.0/(TICKSPEED/4.0));
		
		const double smpsPer16th = ((60.0/newTime.bpm)*getSampleRate())/(TICKSPEED/4.0);
		double smpsFrom16th = beats16th*smpsPer16th-getLatencySamples();
		
		const double pulseSmpLength = TICKLENGTH/1000.0*getSampleRate();
		
		while (smpsFrom16th<0 ) smpsFrom16th+=smpsPer16th;
		
		if (getNumInputChannels()>0) {
			double smpCount = smpsFrom16th;
			
			if (smpsPer16th>0) {
				
				float* channelData = buffer.getSampleData (0);
				
				for (int i = 0; i < numSamples; ++i)
				{
					const double modCount = fmod(smpCount,smpsPer16th);
					
					if (modCount<pulseSmpLength) {
						channelData[i] = +1.0;
					} else {
						channelData[i] = 0.0f;
					}
					
					smpCount+=1;
					
				}
				
			}
			
			for (channel = 1; channel < getNumInputChannels(); ++channel)
			{
				float* firstChannelData = buffer.getSampleData (0);
				float* channelData = buffer.getSampleData (channel);
				
				for (int i = 0; i < numSamples; ++i)
				{
					channelData[i] = firstChannelData[i];
				}
				
			}
		}
		
	} else {
		for (int i = 0; i < getNumInputChannels(); ++i)
			buffer.clear (i, 0, buffer.getNumSamples());
	}

    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());


}

//==============================================================================
AudioProcessorEditor* ACME4PluginAudioProcessor::createEditor()
{
    return new ACME4PluginAudioProcessorEditor (this);
}

//==============================================================================
void ACME4PluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:

    // Create an outer XML element..
    XmlElement xml ("MYPLUGINSETTINGS");

    // add some attributes to it..
    xml.setAttribute ("uiWidth", lastUIWidth);
    xml.setAttribute ("uiHeight", lastUIHeight);

    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);
}

void ACME4PluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

    // This getXmlFromBinary() helper function retrieves our XML from the binary blob..
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != 0)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            // ok, now pull out our parameters..
            lastUIWidth  = xmlState->getIntAttribute ("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);
        }
    }
}

const String ACME4PluginAudioProcessor::getInputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ACME4PluginAudioProcessor::getOutputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ACME4PluginAudioProcessor::isInputChannelStereoPair (int /*index*/) const
{
    return true;	
}

bool ACME4PluginAudioProcessor::isOutputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool ACME4PluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool ACME4PluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ACME4PluginAudioProcessor();
}
